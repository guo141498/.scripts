#!/usr/bin/ruby -w
# encoding: utf-8

require 'sqlite3'
require 'fileutils'

# This class is some utils to database of bibus
class DbUtils < SQLite3::Database
  public

  BIBTYPE = %w(article book booklet conference inbook incollection
               inproceedings journal manual)

  def insert(table, keys, val)
    key = "(#{[*keys].join(', ')})"
    qms = "(#{[*keys].map { '?' }.join(', ')})"
    sentence = "insert or replace into #{table} #{key} values #{qms}"
    execute(sentence, val)
  end

  def selects(table, keys, condition, con_val)
    root_select(table, keys, condition, con_val, :abr)
  end

  def nselects(table, keys, condition, con_val)
    root_select(table, keys, condition, con_val, :aba)
  end

  def select(table, keys, condition, con_val)
    root_select(table, keys, condition, con_val, :exa)
  end

  def update(table, update_pairs, con_pairs)
    keys = update_pairs.to_a.transpose[0].join('=?, ') + '=?'
    condis = con_pairs.to_a.transpose[0].join('=? and ') + '=?'

    execute(
      "update #{table} set #{keys} where #{condis}",
      update_pairs.to_a.transpose[1],
      con_pairs.to_a.transpose[1]
    )
  end

  def deletes(table, condition, con_val)
    delete(table, condition, con_val, true)
  end

  def delete(table, condition, con_val, ambgs = false)
    return if condition.empty?
    condition = cdtjoin(condition, ambgs)
    sentence = "delete from #{table} #{condition}"
    execute(sentence, con_val)
  end

  private

  def cdtjoin(condition, ambgs = false, conect = 'and')
    qm = ambgs ? ' like ?' : '=?'
    return '' if [*condition].join(' ') == ''
    'where ' + [*condition].join("#{qm} #{conect} ") + qm
  end

  def root_select(table, keys, condition, con_val, cls)
    ambgs = cls == :aba || cls == :abr
    con_val = [*con_val].map! { |x| "%#{x}%" } if ambgs
    conect = cls == :abr || cls == :exr ? 'or' : 'and'

    keys = [*keys].join(', ')
    condition = cdtjoin(condition, ambgs, conect)

    sentence = "select #{keys} from #{table} #{condition}"

    execute(sentence, con_val)
  end
end

# The class with basic utils to deal with database
class BaseBibUtils
  public

  def initialize(username, user_s, datafile)
    @username = username
    hdir = "/home/#{user_s}/"
    datafile = hdir + datafile
    @db = DbUtils.new(datafile)
    @col_list = get_col_list
  end

  def self.fmtnote(note, mark = '*')
    return '' if note == ''
    "#{mark}  " + note.gsub(/([^\n]\n)([^\n])/, '\1   \2')
       .gsub("\n\n", "\n\n#{mark}  ")
  end

  def self.fmtauthor(ath, maxlen = 100)
    ath.size > maxlen ? ath.sub(/.{0,}?(\w{2,}).+/, '\1') + ' et al' : ath
  end

  def getkeynames(bibid)
    key = @db.select(:bibreflink, :key_id, :ref_id, bibid).flatten
    gkeyn = ->(k) { @db.select(:bibrefkey, :key_name, :key_id, k)[0][0] }

    key.reduce([]) { |a, e| a << gkeyn.call(e) }.sort.join(', ') + ' '
  end

  def link_item(keyname, bibkey)
    ((keyid, _)) = @db.select(:bibrefkey, :key_id, %w(key_name user),
                              [keyname, @username])
    ((bibid, _)) = @db.select(:bibref, :id, :identifier, bibkey)
    return :keywrong unless keyid && bibid
    return :linkexist if linkexist?(keyid, bibid)

    @db.insert('bibreflink', %w(key_id ref_id), [keyid, bibid])
  end

  def unlink_item(keyname, bibkey)
    ((keyid, _)) = @db.select(:bibrefkey, :key_id, %w(key_name user),
                              [keyname, @username])
    ((bibid, _)) = @db.select(:bibref, :id, :identifier, bibkey)
    return :unexist unless linkexist?(keyid, bibid)
    @db.delete(:bibreflink, %w(ref_id key_id), [bibid, keyid])
  end

  private

  def askuser(string)
    puts string
    $stdin.gets
  end

  def is_y?(str)
    str && (str.upcase == "Y\n" || str.upcase == "YES\n") ? true : false
  end

  def get_col_list
    @db.select(:sqlite_master, :sql, %w(type name), %w(table bibref)).to_s
    .gsub(/[^(]+\(([^)]+)\).+/, '\1').split(',')
    .reduce([]) { |a, e| a << e.split(' ')[0] }
  end

  def get_id
    idlist = @db.select(:bibref, :id, nil, nil).flatten.sort
    idlist.each_cons(2).each { |ps| break ps[0] + 1 if ps[0] != ps[1] - 1 } ||
      idlist.last + 1
  end

  def sexit(string)
    puts string
    exit
  end

  def linkexist?(keyid, bibid)
    !@db.select(:bibreflink, :key_id, %w(key_id ref_id), [keyid, bibid]).empty?
  end

  def ask_key(bibkey, cols, content = 'list', tgcol = %w(bibref identifier),
              adcon = nil)
    (tgcol[1], bibkey) = [adcon[0] << tgcol[1], adcon[1] << bibkey] if adcon
    idents = @db.nselects(tgcol[0], cols, tgcol[1], bibkey)

    sexit('No such an item') if idents.empty?
    bibkey = idents.transpose[0]
    ind = idents.size > 1 ? ask_bibkey(bibkey, content) : 0
    idents[ind]
  end

  def ask_bibkey(bibkeys, content = 'list')
    head =  'There are several candidates here, which one do you want to '
    head += content + '?'
    lists = (1..bibkeys.size)
    .reduce('') { |a, e| a << "#{e}. #{bibkeys[e - 1]}\t" }

    puts head
    ask_index(lists, bibkeys.size)
  end

  def ask_index(lists, lenth)
    loop do
      puts "\e[1m\e[32m#{lists}\e[0m"
      ind = $stdin.gets.to_i
      return ind - 1 if ind >= 1 && ind <= lenth
      puts 'Please choose one of them with their order number'
    end
  end
end

# This class provide methods to check the database and only change the note of
# it
class BibusSearch < BaseBibUtils
  public

  def list(bibkey)
    case list_check(bibkey)
    when 'all' then puts @db.select(:bibref, :identifier, nil, nil)
    when 'keys' then listkeys
    when 'single' then listone(bibkey)
    when 'key' then listkey(bibkey)
    else puts 'No such an item'
    end
  end

  def listnote(bibkey)
    (_, note) = ask_key(bibkey, %w(identifier note))
    puts BaseBibUtils.fmtnote(note, "\e[1m\e[32m*\e[0m")
  end

  def get_slist(words)
    words.reduce(nil) do |a, e|
      list = @db.selects(:bibref, %w(identifier id journal volume pages title),
                         %w(title author abstract note), [e, e, e, e])
      a ? a & list : list
    end
  end

  def search(words)
    lists = get_slist(words)
    lists.map! { |a| [a[0], getkeynames(a[1]), jounal(a[2..4]), a[5]] }
    lists.each { |item| printitem(item, 3) }
  end

  def getnote(bibkey)
    ask_key(bibkey, %w(identifier author title note))
  end

  def storenote(bibkey, note)
    @db.update(:bibref, { note: note }, identifier: bibkey)
  end

  def lskey(keyname)
    condition, con_val = [:key_name, :user], [keyname, @username]
    ((key_id, _)) = @db.select(:bibrefkey, :key_id, condition, con_val)
    @db.select(:bibreflink, :ref_id, :key_id, key_id).flatten
  end

  private

  JNLHASH = { '\apj' => 'ApJ', 'jcap' => 'JCAP', '\apjl' => 'ApJL' }

  def jounal(array)
    array[0] = JNLHASH[array[0]] if JNLHASH.key?(array[0])
    array.join(' ')
  end

  def listone(bibkey)
    info =
      ask_key(bibkey, %w(identifier id author journal volume pages  title))

    info[2] = BaseBibUtils.fmtauthor(info[2])

    printitem([info[2], getkeynames(info[1]),
               jounal(info[3..5]), "\n#{info[6]}"], 3)
  end

  EXC_KLS = %w(All newtmp Tagged Online Import Trash Cited Query)
  MKID = 1
  def listkeys
    @keys = @db.select(:bibrefkey, %w(key_id parent key_name),
                       :user, `echo $USER`.chomp)
      .select { |ele| ele[1] && !EXC_KLS.index(ele[2]) }
    origin = @keys.select { |ele| ele[1] == MKID }
    origin.each { |ele| printkeys(ele) }
  end

  def printkeys(ele, gener = 0)
    puts gener == 0 ? ele[2] :  '    |' * (gener - 1) + '   >|' + ele[2]
    @keys.select { |sele| sele[1] == ele[0] }
      .each { |sele| printkeys(sele, gener + 1) }
  end

  def listkey(keyname = nil)
    (key, _) = ask_key(keyname, %w(key_name), 'list',
                       %w(bibrefkey key_name), [[:user], [@username]])

    puts "\e[1m\e[36m#{key}: \e[0m"

    lskey(key).map { |id| @db.select(:bibref, %w(identifier title), :id, id) }
    .each { |content| printitem(content) }
  end

  def printitem(con, highlight = 1)
    con.flatten!
    head = "\e[1m\e[32m#{con.shift} " if highlight >= 1
    head += "\e[1m\e[36m#{con.shift} " if highlight >= 2
    head += "\e[1m\e[37m#{con.shift} " if highlight == 3
    puts "#{head}\e[0m#{con.join(' ')}"
  end

  def list_check(bibkey)
    return 'all' unless bibkey
    return 'keys' if bibkey == 'keys'
    return 'key' if @db.selects(:bibrefkey, :key_id,
                                :key_name, bibkey).size > 0
    return 'single' if @db.selects(:bibref, :id, :identifier, bibkey).size > 0
  end
end

# To read information form bibtex file
module BibReader
  attr_reader :bibitems, :bibtype

  # To packaging the detail of reading bibtex file
  class PrivBibReader
    attr_reader :bibitems, :bibtype

    public

    def initialize(tmpfile, col_list)
      (@col_list, @bibitems)  = [col_list, {}]
      content = getcontent(File.new(File.expand_path(tmpfile)))
      @bibtype = content.shift.sub(/^@(\w+){.+\n$/, '\1')
      dowarn(readitems(content))
      bibitem = @bibitems.map { |key, val| [translate(key), val] }
        .select { |key, _| colexist?(key.to_s) }
      @bibitems = Hash[bibitem]
      clearname
    end

    private

    TRANSMAP = { adsurl: :custom1 }

    def getcontent(file)
      @swh = false
      file.lines.reduce([]) { |a, e| bibcont?(e) ? a << e : a }
    end

    def bibcont?(line)
      @swh = false if /^}$/ =~ line
      @swh = true if /^@\w+{.+,$/ =~ line
      @swh
    end

    def dowarn(sign)
      puts 'Warning::dislocation occuring' if sign == :dislocation
    end

    def translate(key)
      TRANSMAP[key] || key
    end

    def clearname
      @bibitems[:author].gsub!(/[{}]/, '')
    end

    def colexist?(colname)
      @col_list.each do |item|
        return true if item.downcase == colname.downcase
      end
      false
    end

    def op_bra(strings)
      braces = { '{' => '}', '(' => ')', '"' => '"' }
      braces = braces.merge(braces.invert)
      strings.reverse.chars.reduce('') { |a, e| a << braces[e] }
    end

    def next_line(content)
      line = content.shift
      line == "\n" ? next_line(content) : line
    end

    def readfirst(content)
      item_first_line = /\s*
        (?<keys>\w+)
        \s*=\s*
        (?<lbrace> "?{? )
        (?<vals>.+)
        /x
      line = next_line(content)
      line ? item_first_line.match(line).to_a[1..-1] : :emptyline
    end

    def readtail(keys, content, ends)
      loop do
        return :itemover if @bibitems[keys].sub!(ends, '')
        line = content.shift || return
        /\s*(?<valtmp>\s.+)/ =~ line && @bibitems[keys] << valtmp
      end
    end

    def readitems(content)
      loop do
        (keys, lbrace, vals) = readfirst(content)
        return :dislocation unless keys
        keys == :emptyline ? return : keys = keys.to_sym
        @bibitems.store(keys, vals) && (ends = /#{op_bra(lbrace)},?\s*\z/)

        return unless readtail(keys, content, ends)
      end
    end
  end

  def readbib(tmpfile, col_list)
    reader = PrivBibReader.new(tmpfile, col_list)
    @bibitems = reader.bibitems
    @bibtype = reader.bibtype
  end
end

# This class provide all the methods needed
class Bibus < BibusSearch
  attr_reader :db, :username
  include BibReader

  public

  def initialize(username, user_s, datafile,
                 refdir = '/home/linsj/Documents/Reference')
    @refdir = refdir
    super(username, user_s, datafile)
  end

  def addbib(filename, tmpfile = '~/Documents/tmp.bib')
    readbib(tmpfile, @col_list)
    @bibitems.store(:bibliographictype,
                    DbUtils::BIBTYPE.index(@bibtype.downcase))
    (id, bibkey) = [get_id, get_bibkey]
    (keylist, valist) = get_updatelist(id, bibkey)

    @db.insert('bibref', keylist, valist)
    @db.update(:bibref, { url: "#{@refdir}/#{bibkey}.pdf" },
               identifier: bibkey)
    link_item('newtmp', bibkey)
    addfile(filename, bibkey)
  end

  def links(keyname, bibkey)
    (keyname, _) = ask_key(keyname, :key_name, 'link to',
                           %w(bibrefkey key_name), [[:user], [@username]])
    (bibkey, _) = ask_key(bibkey, :identifier, 'link')
    tl =  link_item(keyname, bibkey) == :linkexist ? 'was exist' : 'is created'
    puts 'The link ' + tl
  end

  def delinks(keyname, bibkey)
    (keyname, keyid) = ask_key(keyname, %w(key_name key_id), 'unlink to',
                         %w(bibrefkey key_name), [[:user], [@username]])
    (bibkey, bibid) = ask_key(bibkey, %w(identifier id), 'unlink')

    tl = unlink_item(keyname, bibkey) == :unexist ? 'was not exist' : 'is removed'
    puts 'The link ' + tl
  end

  def d_bib(bibkey)
    (bibkey, _) = ask_key(bibkey, :identifier, 'delete')

    act_sign = askuser("Do you actually want to delete #{bibkey}?")
    rmques = 'Do you want to remove the corresponding file?'
    rm_sign = is_y?(act_sign) ? askuser(rmques) : nil

    return unless is_y?(act_sign)
    debib_action(bibkey, rm_sign)
  end

  def debib_action(bibkey, rm_sign)
    ((bibid, _)) = @db.select(:bibref, :id, :identifier, bibkey)
    path = @refdir + "/#{bibkey}.pdf"
    FileUtils.rm(path) if is_y?(rm_sign) && File.exist?(path)
    @db.delete(:bibref, :id, bibid)
    @db.delete(:bibreflink, :ref_id, bibid)
  end

  def modbib(tmpfile = '~/Documents/tmp.bib')
    readbib(tmpfile, @col_list)
    @bibitems.store(:bibliographictype,
                    DbUtils::BIBTYPE.index(@bibtype.downcase))
    (bibkey, id) =
      ask_key(@bibitems[:author][/\w{2,}/] + @bibitems[:year][/\w{2,}/],
              %w(identifier id))
    uplist = get_updatelist(id, bibkey).transpose

    @db.update(:bibref, uplist, id: id)
  end

  def opbib_core(identi)
    system("gvfs-open #{@refdir}/#{identi}.pdf &")
    writelogfile(File.expand_path('~/.opbib_history'), identi)
  end

  def opbib(bibkey)
    (identi, _) = ask_key(bibkey, %w(identifier), 'open')
    opbib_core(identi)
  end

  private

  def writelogfile(filename, item)
    history = File.new(filename).lines.to_a
    history << "#{Time.now} #{item}\n"
    history.shift if history.size >= 1000

    file = File.new(filename, 'w')
    file.puts(history)
    file.close
  end

  def get_bibkey
    bibkey = @bibitems[:author][/\w{2,}/] + @bibitems[:year][/\w{2,}/]
    exi_item = @db.selects(:bibref, :identifier, :identifier, bibkey).flatten

    return bibkey if exi_item.empty?
    bibkey = exi_item.sort.last
    bibkey[/[0-9]\z/] ? bibkey += 'a' : bibkey.succ!
  end

  def addfile(filename, bibkey)
    if File.file?(filename)
      FileUtils.mv(filename, "#{@refdir}/#{bibkey}.pdf")
    else
      puts 'file not exist'
    end
  end

  def get_updatelist(id, bibkey)
    keylist = @bibitems.each_key.reduce(%w(id identifier), :<<)
    valist = @bibitems.each_value.reduce([id, bibkey], :<<)
    [keylist, valist]
  end
end
