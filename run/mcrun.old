#!/home/linsj/bin/ruby
# encoding: utf-8

def get_tail(arr)
  arr.map { |x| /cosraymc(?<tail>\w*)/ =~ x && tail }.reject { |x| !x }.uniq
end

def ask(choices, sentence, key_type = :sym)
  puts sentence
  loop do
    sign = $stdin.gets.chomp
    sw = key_type == :sym ? sign.to_sym : sign.to_i
    break choices[sw] unless choices[sw].nil?
    break choices.to_a.transpose[1] if 'a' == sign
    break if 'q' == sign
  end
end

def run_cosray(tail, i, sec = 3)
  str = %Q(./cosraymc#{tail} inifile/galp#{tail}.ini #{i} > "nohup#{tail}_#{i}.out")
  system(str + ' &')
  sleep(sec)
end

CST = "Which do you want to do? Run (c)osraymc, (g)etdist or (k)ill the task\n"
JST = 'Do you actually want to '
clist = { c: 'c', g: 'g', k: 'k', s: 's' }
ti = Time.now.strftime('%m.%d-%H:%M')
maxnum = 4

get_task = %q(ps x | grep cosraymc | awk '{print $5}')
k_task = ->(tl) { %Q(kill `ps xr | grep "cosraymc#{tl} " |awk '{print $1}'`) }

choice = clist[ARGV[0] && ARGV[0].to_sym] || ask(clist, CST)

list = choice == 'k' ? `#{get_task}`.each_line : Dir.foreach('.')
tails = Hash[*get_tail(list).each_with_index.map { |t, i| [i + 1, t] }.flatten]
tst = "Choose the task you want(or print 'a'/'q' for all/quit).\n" \
  + tails.map { |it| it.join('.') }.join('  ')
selected = ARGV[1] && ARGV[1..-1].select { |x| tails.value?(x) }
tail = selected && selected[0] ? selected : [*ask(tails, tst, :int)]

y_or_n = { y: true, n: false }

case choice
when 's'
  puts "setting chains number to #{ARGV[-1].to_i}"
  subs = ->(l, f) { %Q(sed -i "/^#{l} =/s:[0-9]\\+:#{ARGV[-1].to_i}:g" #{f}) }
  system(subs.call('maxnum', __FILE__))
  tail.each { |t| system(subs.call('chain_num', "inifile/distgalp#{t}.ini")) }
when 'c'
  tail.map { |t| [t, ask(y_or_n, JST + "start new chains #{t}?\n")] }
    .each { |t, sw| (1..maxnum).each { |i| run_cosray(t, i) } if sw }
when 'k'
  kask = ->(t) { ask(y_or_n, JST + "kill the tasks #{t}?\n") }
  tail.each { |t| system(k_task.call(t)) if kask.call(t) }
when 'g'
  ged = -> (t) { system("./getdist inifile/distgalp#{t}.ini | tee out/distlog/#{t}#{ti}") }
  tail.each { |t| ged.call(t) }
end
