#!/home/linsj/bin/ruby
# encoding: utf-8

require 'fileutils'

# This script is used to mount the known disk (including usb disk) easily

class DiskLabel

  LABEL_PATH = '/dev/disk/by-label/'

  def initialize
    deallab = ->(l) { [linkpt(l).to_sym, formchar(l)] if File.symlink?(l) }
    @label = Hash[Dir["#{LABEL_PATH}/*"].map { |x| deallab.call(x) }.compact]
  end

  def lab(disk)
    @label[disk.to_sym]
  end

  private
  def formchar(file)
    unescape(file.gsub(%r(^.+/([^/]+)$), '\1')).encode('utf-8', 'gbk')
  end

  def unescape(src)
    String.class_eval(%Q("#{src}"))
  end

  def parent(file)
    file.gsub(%r((^.+)/[^/]+$), '\1')
  end

  def linkpt(lnfile)
    File.expand_path("#{parent(lnfile)}/#{File.readlink(lnfile)}")
  end
end

class DiskMP
  def initialize
    @mount_point = Hash[`df`.each_line.to_a[1..-1].map { |l| deallinedf(l) }]
  end

  def deallinedf(line)
    term = line.split(' ')
    [term[0].to_sym, term[-1]]
  end

  def path(disk)
    @mount_point[disk.to_sym]
  end
end

class DiskInfo
  attr_reader :disk

  def initialize(str)
    @str, @mp, @label = str, DiskMP.new, DiskLabel.new
    disk = @str.map { |l| %r{^Disk (?<dev>/dev/hd\w|/dev/sd\w)} =~ l and dev }
    .compact
    @disk = Hash[disk.map { |k| [k, subdisk(k)]}]
  end

  private

  def subdisk(dk)
    hash = Hash[@str.map { |l| /^#{dk}/ =~ l and readsubinfo(l) }.compact]
    hash.empty? ? readwholeinfo(dk) : hash
  end

  COLS = [:device, :boot, :start, :end, :blocks, :id, :system, :path, :label]
  COLNUM = COLS.size - 1
  def readwholeinfo(dk)
    ind = @str.find_index { |l| /#{dk}/ =~ l }
    %r{^Disk /dev/\w+[^\d]+[0-9.]+ \w+[^\d]+\d+[^\d]+(?<sec>\d+)} =~ @str[ind]
    /^Disklabel type: (?<sys>.+)$/ =~ @str[ind + 4]
    values = [nil, 0, sec, sec, nil, sys, @mp.path(dk), @label.lab(dk)]
    hash = Hash[COLS[1..COLNUM].zip(values)]
    hash[:blocks] = num_to_G(hash[:blocks])
    hash
  end

  def readsubinfo(line)
    term = line.split(' ')
    term.insert(1, nil) unless term[1] == '*'
    term[COLNUM - 2] = term[COLNUM - 2..-1].join(' ')
    term[COLNUM - 1], term[COLNUM] = @mp.path(term[0]), @label.lab(term[0])

    hash = Hash[COLS[1..COLNUM].zip(term[1..COLNUM])]
    hash[:blocks] = num_to_G(hash[:blocks])
    [term[0], hash]
  end

  def num_to_G(num)
    num.is_a?(String) ? num.to_f / (1000 * 1000) : num
  end
end

class DiskMounter
  def initialize(info, ignore)
    @info, @ignore = info, ignore
  end

  ASK_WITCH = "\e\[33mWhich disk do you want to mount (umount)?\e\[0m\n"
  HINT = "\e\[33m\e\[1mPlease input a number.\e\[0m\n"
  QUIT_HINT = "\e\[33m\e\[1mStop mounting (unmounting)...\e\[0m\n"

  def ask
    @keylist = [:empty]
    infostr = pinfo
    stat = loop do
      puts ASK_WITCH + infostr

      ch = $stdin.gets.chomp
      break :quit if %w(q quit Q Quit).include?(ch)

      ind = ch.to_i
      break @current = @keylist[ind] if (1..@keylist.size - 1).include?(ind)

      puts HINT
    end

    return unless stat == :quit
    puts QUIT_HINT
    exit 1
  end

  def mount
    return unless @current
    value = flat(@info)[@current]
    value[:path] ? umount_act(value[:path]) : mount_act(@current, value)
  end

  private

  M_DIR = '~/mnt'
  USER = `echo $USER`.chomp
  M_OPTION = { iocharset: 'utf8', uid: USER, gid: USER, fmask: '133', \
             dmask: '022' }
  def mount_act(key, val)
    command = 'sudo mount -o ' \
      + M_OPTION.each.map { |o, v| "#{o}=#{v}" }.join(',') \
      + " #{key} #{path = getpath(key, val)}"
    FileUtils.mkdir(path) unless File.exist?(path)

    puts command
    system(command)
  end

  UNMOUNT_FAIL_ERR = "\e\[31m\e\[1mError: Unmount failed\e\[0m\n"
  def umount_act(path)
    system("sudo umount #{path}")
    return(puts(UNMOUNT_FAIL_ERR)) if Dir["#{path}/{*,.*}"].size > 2
    system("rm -rf #{path}")
  end

  def getpath(key, val)
    File.expand_path("#{M_DIR}/#{val[:label] or key.sub(%r{/dev/}, '')}")
  end

  def flat(info)
    Hash[info.map { |k, v| v[:start] ? [[k, v]] : v.to_a }.flatten(1)]
  end

  def pinfo(info = @info)
    judge = ->(k, v) { v[:start] ? getline(k, v) : psubinfo(v) }
    info.map { |k, v| "  \e\[37m#{k}\e\[0m\n" + judge.call(k, v) }.join("\n\n")
  end

  def psubinfo(info)
    info.map { |k, v| getline(k, v) }.compact.join("\n")
  end

  def getline(key, val)
    return if ignore(key, val)
    ind = (@keylist << key).size - 1
    "\t\e\[1m#{ind}. #{val[:label] || key}" + \
    "\t\e\[37m#{format("%.3g G", val[:blocks])}" + \
    "\t\e\[36m#{val[:path]}\e\[0m" + \
    "\e\[35m\t#{val[:system] and "[#{val[:system]}]"}\e\[0m"
  end

  def ignore(key, val)
    @ignore[:system].include?(val[:system]) or
      @ignore[:path].include?(val[:path])
  end
end

IGNORE = { system: ['Linux LVM', "W95 Ext'd (LBA)"], path: ['/home', '/boot'] }

info = DiskInfo.new(`sudo fdisk -l`.each_line.to_a)
mounter = DiskMounter.new(info.disk, IGNORE)
mounter.ask
mounter.mount
